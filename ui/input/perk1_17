Manifest(perk for 1_17 manhunt, 7, by ItsGeomecraft)

#CONSTANTS
EFFECT_DEFAULT_LENGTH = 3
UNDEAD = [zombie, skeleton,zombified_piglin]

#some general purpose abstraction functions
def abstract forPerk(perkScore, runnable){
    execute as @a[scores={<perkScore>=1}] run execute at @s run <runnable>
}
def abstract link(function, waitTime){
    schedule function <function> <waitTime>
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~mutual_hunt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
namespace.set(mutual_hunt)

onLoad(scoreboard objectives add player dummy)

def store_player_position_into_storage(){
#player 1
execute as @a[scores={player=1},limit=1] at @s store result storage player1_coord X int 1 run data get entity @s Pos[0]
execute as @a[scores={player=1},limit=1] at @s store result storage player1_coord Y int 1 run data get entity @s Pos[1]
execute as @a[scores={player=1},limit=1] at @s store result storage player1_coord Z int 1 run data get entity @s Pos[2]
#player 2
execute as @a[scores={player=2},limit=1] at @s store result storage player2_coord X int 1 run data get entity @s Pos[0]
execute as @a[scores={player=2},limit=1] at @s store result storage player2_coord Y int 1 run data get entity @s Pos[1]
execute as @a[scores={player=2},limit=1] at @s store result storage player2_coord Z int 1 run data get entity @s Pos[2]
link(mutual_hunt:store_player_position_into_storage, 1t)
}

def compass_update(){
execute as @a[scores={player=1},nbt={Inventory:[{Slot:8b, id:"minecraft:compass",Count:1b}]},limit=1] run item modify entity @s container.8 mutual_hunt:compass_update_player1
execute as @a[scores={player=2},nbt={Inventory:[{Slot:8b, id:"minecraft:compass",Count:1b}]},limit=1] run item modify entity @s container.8 mutual_hunt:compass_update_player2
link(mutual_hunt:compass_update, 1t)
}

def compass_setup(){
    item modify entity @s container.8 mutual_hunt:compass_setup
}

def compass_lose_player(){
    #player1
    execute if entity @a[scores={player=2},nbt={Dimension:"minecraft:overworld"},limit=1] run execute as @a[scores={player=1},nbt={Inventory:[{Slot:8b, id:"minecraft:compass",Count:1b}]},limit=1] run item modify entity @s container.8 mutual_hunt:compass_overworld
    execute if entity @a[scores={player=2},nbt={Dimension:"minecraft:the_nether"},limit=1] run execute as @a[scores={player=1},nbt={Inventory:[{Slot:8b, id:"minecraft:compass",Count:1b}]},limit=1] run item modify entity @s container.8 mutual_hunt:compass_the_nether
    execute if entity @a[scores={player=2},nbt={Dimension:"minecraft:the_end"},limit=1] run execute as @a[scores={player=1},nbt={Inventory:[{Slot:8b, id:"minecraft:compass",Count:1b}]},limit=1] run item modify entity @s container.8 mutual_hunt:compass_the_end

    #player2
    execute if entity @a[scores={player=1},nbt={Dimension:"minecraft:overworld"},limit=1] run execute as @a[scores={player=2},nbt={Inventory:[{Slot:8b, id:"minecraft:compass",Count:1b}]},limit=1] run item modify entity @s container.8 mutual_hunt:compass_overworld
    execute if entity @a[scores={player=1},nbt={Dimension:"minecraft:the_nether"},limit=1] run execute as @a[scores={player=2},nbt={Inventory:[{Slot:8b, id:"minecraft:compass",Count:1b}]},limit=1] run item modify entity @s container.8 mutual_hunt:compass_the_nether
    execute if entity @a[scores={player=1},nbt={Dimension:"minecraft:the_end"},limit=1] run execute as @a[scores={player=2},nbt={Inventory:[{Slot:8b, id:"minecraft:compass",Count:1b}]},limit=1] run item modify entity @s container.8 mutual_hunt:compass_the_end
    link(mutual_hunt:compass_lose_player, 1t)
}

item.modifier.setNBT(compass_setup, tag, "<{LodestoneDimension:"minecraft:overworld",LodestoneTracked:0b,LodestonePos:{X:1,Y:1,Z:1}}>")
item.modifier.copyNBT(compass_update_player1, minecraft:player2_coord, X, LodestonePos.X, replace, Y, LodestonePos.Y, replace, Z, LodestonePos.Z, replace)
item.modifier.copyNBT(compass_update_player2, minecraft:player1_coord, X, LodestonePos.X, replace, Y, LodestonePos.Y, replace, Z, LodestonePos.Z, replace)

item.modifier.setNBT(compass_overworld, tag, "<{LodestoneDimension:"minecraft:overworld"}>")
item.modifier.setNBT(compass_the_nether, tag, "<{LodestoneDimension:"minecraft:the_nether"}>")
item.modifier.setNBT(compass_the_end, tag, "<{LodestoneDimension:"minecraft:the_end"}>")


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~mutual_hunt~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~perk~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
#-----basic set up-----#
#PERK CONSTANTS
PERK_SCORE = [en_re, ho_sm, frag, fa_ca, phoe]
HELPER_PERK_SCORE = [ho_sm_count, phoe_charge]

namespace.set(perk)
def basic_property_score_setup(){
    scoreboard objectives add health health
    scoreboard objectives add death_count deathCount
    scoreboard objectives add gapple_count minecraft.used:minecraft.golden_apple
    scoreboard objectives add god_gapple_count minecraft.used:minecraft.enchanted_golden_apple
    scoreboard objectives add fire_tick dummy
}
def property_score_maintain(){
    execute as @a store result score @s fire_tick run data get entity @s Fire
}
onTick(function perk:property_score_maintain)
def scores_declare(){
    for.each(x, >PERK_SCORE<, scoreboard objectives add <x> dummy)
}
def helper_score_declare(){
    for.each(x, >HELPER_PERK_SCORE<, scoreboard objectives add <x> dummy)
}
onLoad(function perk:basic_property_score_setup, function perk:scores_declare, function perk:helper_score_declare)
onLoad("<tellraw @a {"text":"Perk for 1.17 loading succesful","color":"gold"}>")

def heal(){
    effect give @s minecraft:saturation 20
}
#-----basic set up-----#
#-----actual perk-----#
def enhanced_resiliance(){
    function perk:enhanced_resiliance_loop
}
def enhanced_resiliance_loop(){
    forPerk(en_re, execute if score @s health matches 10.. run effect give @s resistance >EFFECT_DEFAULT_LENGTH< 0 true)
    forPerk(en_re, execute if score @s health matches ..10 run effect give @s resistance >EFFECT_DEFAULT_LENGTH< 1 true)
    link(perk:enhanced_resiliance_loop, 1t)
}

def holy_smite(){
    function perk:holy_smite_limit_maximum
    wait(28s, perk:holy_smite_loop)
}
def holy_smite_loop(){
    forPerk(ho_sm, give @s snowball{holy_smite:1b})
    loop(0, 28s)
}
def holy_smite_limit_maximum(){
    forPerk(ho_sm, execute store result score @s ho_sm_count run clear @s minecraft:snowball{holy_smite:1b} 0)
    forPerk(ho_sm, execute if score @s ho_sm_count matches 4.. run clear @s minecraft:snowball{holy_smite:1b} 1)
    loop()
}
onLand(holy_smite, function perk:first_smite)
def first_smite(){
    summon minecraft:lightning_bolt ~ ~ ~
    summon area_effect_cloud ~ ~ ~ {Duration:23,Tags:["holy_smite"]}
    schedule function perk:second_smite 11t append
}
def second_smite(){
    for.each(x, >UNDEAD<, "<execute as @e[type=minecraft:area_effect_cloud, tag=holy_smite, nbt={Age:10}] at @s run execute at @e[type=<x>,distance=..5] run summon lightning_bolt ~ ~ ~>")
    schedule function perk:third_smite 11t append
}
def third_smite(){
    for.each(x, >UNDEAD<, "<execute as @e[type=minecraft:area_effect_cloud, tag=holy_smite, nbt={Age:21}] at @s run execute at @e[type=<x>,distance=..5] run summon lightning_bolt ~ ~ ~>")
}

def fragmentation(){
    wait(32s, perk:fragmentation_loop)
}
def fragmentation_loop(){
    forPerk(frag, give @s tnt)
    loop(0, 32s)
}

recipe.shaped(fake_emerald_block, emerald_block, 1, empty, green_dye, empty, green_dye, chiseled_stone_bricks, green_dye, empty, green_dye, empty)
recipe.shaped(fake_gold_block, gold_block, 1, empty, yellow_dye, empty, yellow_dye, smooth_stone, yellow_dye, empty, yellow_dye, empty)
recipe.restrict(perk:fake_emerald_block, @a)
recipe.restrict(perk:fake_gold_block, @a)
def fake_cash(){
    forPerk(fa_ca, recipe give @s perk:fake_emerald_block)
    forPerk(fa_ca, recipe give @s perk:fake_gold_block)
}

def phoenix(){
    forPerk(phoe, scoreboard players set @s phoe_charge 1)
    function perk:phoenix_loop
}
def phoenix_loop(){
    forPerk(phoe, execute if score @s gapple_count matches 1 run function perk:phoenix_refresh)
    forPerk(phoe, execute if score @s god_gapple_count matches 1 run function perk:phoenix_refresh)
    forPerk(phoe, execute if score @s health matches ..10 if score @s fire_tick matches 1.. if score @s phoe_charge matches 1 run function perk:phoenix_reborn)
    loop()
}
def phoenix_reborn(){
    effect give @s minecraft:regeneration 30 0
    effect give @s minecraft:fire_resistance 30 0
    scoreboard players set @s phoe_charge 0
    tellraw @s [{"text":"Phoenix has been ","color":"aqua"},{"text":"activated","color":"light_purple"}]
}
def phoenix_refresh(){
    scoreboard players set @s phoe_charge 1
    scoreboard players set @s gapple_count 0
    scoreboard players set @s god_gapple_count 0
    tellraw @s [{"text":"Phoenix has been ","color":"aqua"},{"text":"recharged","color":"light_purple"}]
}

#-----actual perk-----#
#-----starting function-----#
#main function
def start(){
    function perk:stop

    #compass tracking
    function mutual_hunt:store_player_position_into_storage
    function mutual_hunt:compass_update
    function mutual_hunt:compass_lose_player

    #perk
    function perk:enhanced_resiliance
    function perk:holy_smite
    function perk:fragmentation
    function perk:fake_cash
    function perk:phoenix
}
# TODO
# score.clear
def stop(){
    break.all()
}
#-----starting function-----#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~perk~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#